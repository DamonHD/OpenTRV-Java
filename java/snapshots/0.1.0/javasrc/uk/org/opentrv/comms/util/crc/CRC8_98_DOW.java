/*
The OpenTRV project licenses this file to you
under the Apache Licence, Version 2.0 (the "Licence");
you may not use this file except in compliance
with the Licence. You may obtain a copy of the Licence at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing,
software distributed under the Licence is distributed on an
"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, either express or implied. See the Licence for the
specific language governing permissions and limitations
under the Licence.

Author(s) / Copyright (s): Damon Hart-Davis 2014



Note from pycrc 0.8.1 README:

    Copyright of the generated source code
    ======================================

    Prior to v0.6, pycrc was released under the GPL and an additional addition to
    the licence was required to permit to use the generated source code in products
    with a OSI unapproved licence. As of version 0.6, pycrc is released under the
    terms of the MIT licence and such an additional clause to the licence is no
    more required.
    The code generated by pycrc is not considered a substantial portion of the
    software, therefore the licence does not cover the generated code, and the
    author of pycrc will not claim any copyright on the generated code.
*/

package uk.org.opentrv.comms.util.crc;

/**Dallas (now Maxim) OneWire(TM) 8-bit iButton CRC calculation.
 * Mirrors C/C++/etc implementations used elsewhere.
 * <p>
 * See http://www.maxim-ic.com/appnotes.cfm/appnote_number/27
 * <p>
 * Polynomial: x^8 + x^5 + x^4 + 1 (0x8C)
 * Initial value: 0x0
 * <p>
 * See http://users.ece.cmu.edu/~koopman/roses/dsn04/koopman04_crc_poly_embedded.pdf
 * Also: http://users.ece.cmu.edu/~koopman/crc/
 * Also: http://www.ross.net/crc/crcpaper.html
 * Also: http://en.wikipedia.org/wiki/Cyclic_redundancy_check
 * <p>
 * Also see PYCRC http://www.tty1.net/pycrc/
 * from which checksums and code fragments have been generated.
 */
public final class CRC8_98_DOW
    {
    private CRC8_98_DOW() { /* prevent instance creation */ }

    /**Update 8-bit CRC with next byte.
     * http://www.maxim-ic.com/appnotes.cfm/appnote_number/27
     * <p>
     * Polynomial 0x98 (10011000, "DOWCRC", Koopman) = x^8 + x^5 + x^4 + 1 = 0x31 (110001, normal) 0x8c (10001100, reversed)
     * <p>
     * Usually initialise with 0x0.
     * <p>
     * See: http://users.ece.cmu.edu/~koopman/roses/dsn04/koopman04_crc_poly_embedded.pdf
     * <p>
     * Should detect all 1-, 2- and 3- bit errors on up to 119 bits (14 bytes) of payload,
     * see: http://users.ece.cmu.edu/~koopman/crc/0x98.txt
     * <p>
     * Simple bitwise implementation with lsb first and thus a reversed polynomial.
     */
    public static byte crc8_98_DOW_update(byte crc, final byte datum)
        {
        crc ^= datum;
        for(int i = 0; i < 8; ++i)
            {
            if(0 != (crc & 1)) { crc = (byte) (((crc >> 1) & 0x7f) ^ 0x8C); }
            else { crc = (byte)((crc >> 1) & 0x7f); }
            }
        return(crc);
        }

    /**Overloading to help when calling with int args, eg literals. */
    public static byte crc8_98_DOW_update(final int crc, final int datum)
        { return(crc8_98_DOW_update((byte)crc, (byte)datum)); }


    // Bit-by-bit algorithm.
    // Derived from code generated with ./pycrc.py --model=dallas-1-wire --algo=bbb --generate=X
//    * Functions and types for CRC checks.
//    *
//    * Generated on Sun May  4 11:04:31 2014,
//    * by pycrc v0.8.1, http://www.tty1.net/pycrc/
//    * using the configuration:
//    *    Width        = 8
//    *    Poly         = 0x31
//    *    XorIn        = 0x00
//    *    ReflectIn    = True
//    *    XorOut       = 0x00
//    *    ReflectOut   = True
//    *    Algorithm    = bit-by-bit

    /**Initialisation, bit-by-bit code version. */
    public static byte bbb_init() { return(0); }

    /**Internal routine to reflect data.
<pre>
Derived from fragment generated with:
    ./pycrc.py --model=dallas-1-wire --algo=bbb --generate=c

 * Reflect all bits of a \a data word of \a data_len bytes.
 *
 * \param data         The data word to be reflected.
 * \param data_len     The width of \a data expressed in number of bits.
 * \return             The reflected data.
 *****************************************************************************
crc_t crc_reflect(crc_t data, size_t data_len)
{
    unsigned int i;
    crc_t ret;

    ret = data & 0x01;
    for (i = 1; i < data_len; i++) {
        data >>= 1;
        ret = (ret << 1) | (data & 0x01);
    }
    return ret;
}
</pre>
     */
    static byte crc_reflect(byte data, final int data_len)
        {
        byte ret = (byte)(data & 0x01);
        for (int i = 1; i < data_len; ++i)
            {
            data >>= 1;
            ret = (byte) ((ret << 1) | (data & 0x01));
            }
        return(ret);
        }

    /**Update, bit-by-bit-version.
<pre>
Derived from fragment generated with:
    ./pycrc.py --model=dallas-1-wire --algo=bbb --generate=c

 * Update the crc value with new data.
 *
 * \param crc      The current crc value.
 * \param data     Pointer to a buffer of \a data_len bytes.
 * \param data_len Number of bytes in the \a data buffer.
 * \return         The updated crc value.
 *****************************************************************************
crc_t crc_update(crc_t crc, const unsigned char *data, size_t data_len)
{
    unsigned int i;
    bool bit;
    unsigned char c;

    while (data_len--) {
        c = crc_reflect(*data++, 8);
        for (i = 0; i < 8; i++) {
            bit = crc & 0x80;
            crc = (crc << 1) | ((c >> (7 - i)) & 0x01);
            if (bit) {
                crc ^= 0x31;
            }
        }
        crc &= 0xff;
    }
    return crc & 0xff;
}
</pre>
     */
    public static byte bbb_update(byte crc, final byte data[], int data_len)
        {
        int index = 0;
        while(data_len-- > 0)
            {
            final byte c = crc_reflect(data[index++], 8);
            for(int i = 0; i < 8; i++)
                {
                final boolean bit = (0 != (crc & 0x80));
                crc = (byte) ((crc << 1) | ((c >> (7 - i)) & 0x01));
                if(bit) { crc ^= 0x31; }
                }
            // crc &= 0xff;
            }
        return(crc); // return crc & 0xff;
        }

    /**Finish, bit-by-bit version.
<pre>
Derived from fragment generated with:
    ./pycrc.py --model=dallas-1-wire --algo=bbb --generate=c

 * Calculate the final crc value.
 *
 * \param crc  The current crc value.
 * \return     The final crc value.
 *****************************************************************************
crc_t crc_finalize(crc_t crc)
{
    unsigned int i;
    bool bit;

    for (i = 0; i < 8; i++) {
        bit = crc & 0x80;
        crc = (crc << 1) | 0x00;
        if (bit) {
            crc ^= 0x31;
        }
    }
    crc = crc_reflect(crc, 8);
    return (crc ^ 0x00) & 0xff;
}

</pre>
     */
    public static byte bbb_finalize(byte crc)
        {
        for (int i = 0; i < 8; i++)
            {
            final boolean bit = (0 != (crc & 0x80));
            crc <<= 1; // crc = (crc << 1) | 0x00;
            if (bit) { crc ^= 0x31; }
            }
        crc = crc_reflect(crc, 8);
        return(crc); // return (crc ^ 0x00) & 0xff;
        }

    // Table-driven algorithm, not size constrained.
    // Derived from code generated with ./pycrc.py --model=dallas-1-wire --algo=tbl --generate=X
    public static byte tbl_init() { return(0); }
    public static byte tbl_finalize(final byte crc) { return(crc); }
    /**Full table-driven update code.
<pre>
Derived from fragment generated with:
    ./pycrc.py --model=dallas-1-wire --algo=tbl --generate=c

 * Update the crc value with new data.
 *
 * \param crc      The current crc value.
 * \param data     Pointer to a buffer of \a data_len bytes.
 * \param data_len Number of bytes in the \a data buffer.
 * \return         The updated crc value.
 *****************************************************************************
crc_t crc_update(crc_t crc, const unsigned char *data, size_t data_len)
{
    unsigned int tbl_idx;

    while (data_len--) {
        tbl_idx = (crc ^ *data) & 0xff;
        crc = (crc_table[tbl_idx] ^ (crc >> 8)) & 0xff;

        data++;
    }
    return crc & 0xff;
}

</pre>
     */
    public static byte tbl_update(byte crc, final byte[] data, int data_len)
        {
        int data_index = 0;
        while (data_len-- > 0)
            {
            final int tbl_idx = (crc ^ data[data_index++]) & 0xff;
            crc = tbl_table[tbl_idx];
            }
        return(crc);
        }
    /**Static table used for the table_driven implementation. */
    private static final byte tbl_table[] =
        {
        (byte)0x00, (byte)0x5e, (byte)0xbc, (byte)0xe2, (byte)0x61, (byte)0x3f, (byte)0xdd, (byte)0x83, (byte)0xc2, (byte)0x9c, (byte)0x7e, (byte)0x20, (byte)0xa3, (byte)0xfd, (byte)0x1f, (byte)0x41,
        (byte)0x9d, (byte)0xc3, (byte)0x21, (byte)0x7f, (byte)0xfc, (byte)0xa2, (byte)0x40, (byte)0x1e, (byte)0x5f, (byte)0x01, (byte)0xe3, (byte)0xbd, (byte)0x3e, (byte)0x60, (byte)0x82, (byte)0xdc,
        (byte)0x23, (byte)0x7d, (byte)0x9f, (byte)0xc1, (byte)0x42, (byte)0x1c, (byte)0xfe, (byte)0xa0, (byte)0xe1, (byte)0xbf, (byte)0x5d, (byte)0x03, (byte)0x80, (byte)0xde, (byte)0x3c, (byte)0x62,
        (byte)0xbe, (byte)0xe0, (byte)0x02, (byte)0x5c, (byte)0xdf, (byte)0x81, (byte)0x63, (byte)0x3d, (byte)0x7c, (byte)0x22, (byte)0xc0, (byte)0x9e, (byte)0x1d, (byte)0x43, (byte)0xa1, (byte)0xff,
        (byte)0x46, (byte)0x18, (byte)0xfa, (byte)0xa4, (byte)0x27, (byte)0x79, (byte)0x9b, (byte)0xc5, (byte)0x84, (byte)0xda, (byte)0x38, (byte)0x66, (byte)0xe5, (byte)0xbb, (byte)0x59, (byte)0x07,
        (byte)0xdb, (byte)0x85, (byte)0x67, (byte)0x39, (byte)0xba, (byte)0xe4, (byte)0x06, (byte)0x58, (byte)0x19, (byte)0x47, (byte)0xa5, (byte)0xfb, (byte)0x78, (byte)0x26, (byte)0xc4, (byte)0x9a,
        (byte)0x65, (byte)0x3b, (byte)0xd9, (byte)0x87, (byte)0x04, (byte)0x5a, (byte)0xb8, (byte)0xe6, (byte)0xa7, (byte)0xf9, (byte)0x1b, (byte)0x45, (byte)0xc6, (byte)0x98, (byte)0x7a, (byte)0x24,
        (byte)0xf8, (byte)0xa6, (byte)0x44, (byte)0x1a, (byte)0x99, (byte)0xc7, (byte)0x25, (byte)0x7b, (byte)0x3a, (byte)0x64, (byte)0x86, (byte)0xd8, (byte)0x5b, (byte)0x05, (byte)0xe7, (byte)0xb9,
        (byte)0x8c, (byte)0xd2, (byte)0x30, (byte)0x6e, (byte)0xed, (byte)0xb3, (byte)0x51, (byte)0x0f, (byte)0x4e, (byte)0x10, (byte)0xf2, (byte)0xac, (byte)0x2f, (byte)0x71, (byte)0x93, (byte)0xcd,
        (byte)0x11, (byte)0x4f, (byte)0xad, (byte)0xf3, (byte)0x70, (byte)0x2e, (byte)0xcc, (byte)0x92, (byte)0xd3, (byte)0x8d, (byte)0x6f, (byte)0x31, (byte)0xb2, (byte)0xec, (byte)0x0e, (byte)0x50,
        (byte)0xaf, (byte)0xf1, (byte)0x13, (byte)0x4d, (byte)0xce, (byte)0x90, (byte)0x72, (byte)0x2c, (byte)0x6d, (byte)0x33, (byte)0xd1, (byte)0x8f, (byte)0x0c, (byte)0x52, (byte)0xb0, (byte)0xee,
        (byte)0x32, (byte)0x6c, (byte)0x8e, (byte)0xd0, (byte)0x53, (byte)0x0d, (byte)0xef, (byte)0xb1, (byte)0xf0, (byte)0xae, (byte)0x4c, (byte)0x12, (byte)0x91, (byte)0xcf, (byte)0x2d, (byte)0x73,
        (byte)0xca, (byte)0x94, (byte)0x76, (byte)0x28, (byte)0xab, (byte)0xf5, (byte)0x17, (byte)0x49, (byte)0x08, (byte)0x56, (byte)0xb4, (byte)0xea, (byte)0x69, (byte)0x37, (byte)0xd5, (byte)0x8b,
        (byte)0x57, (byte)0x09, (byte)0xeb, (byte)0xb5, (byte)0x36, (byte)0x68, (byte)0x8a, (byte)0xd4, (byte)0x95, (byte)0xcb, (byte)0x29, (byte)0x77, (byte)0xf4, (byte)0xaa, (byte)0x48, (byte)0x16,
        (byte)0xe9, (byte)0xb7, (byte)0x55, (byte)0x0b, (byte)0x88, (byte)0xd6, (byte)0x34, (byte)0x6a, (byte)0x2b, (byte)0x75, (byte)0x97, (byte)0xc9, (byte)0x4a, (byte)0x14, (byte)0xf6, (byte)0xa8,
        (byte)0x74, (byte)0x2a, (byte)0xc8, (byte)0x96, (byte)0x15, (byte)0x4b, (byte)0xa9, (byte)0xf7, (byte)0xb6, (byte)0xe8, (byte)0x0a, (byte)0x54, (byte)0xd7, (byte)0x89, (byte)0x6b, (byte)0x35
        };

    // Constrained-size table-driven algorithm.
    // Derived from code generated with ./pycrc.py --model=dallas-1-wire --algo=tbl --table-idx-width=4 -v --generate=h
//    * Generated on Sun May  4 12:57:07 2014,
//    * by pycrc v0.8.1, http://www.tty1.net/pycrc/
//    * using the configuration:
//    *    Width        = 8
//    *    Poly         = 0x31
//    *    XorIn        = 0x00
//    *    ReflectIn    = True
//    *    XorOut       = 0x00
//    *    ReflectOut   = True
//    *    Algorithm    = table-driven
    public static byte tb4_init() { return(0); }
    public static byte tb4_finalize(final byte crc) { return(crc); }

    /**Size-constrained table-driven update code.
<pre>
Derived from fragment generated with:
    ./pycrc.py --model=dallas-1-wire --algo=tbl --table-idx-width=4 --generate=c

 * Update the crc value with new data.
 *
 * \param crc      The current crc value.
 * \param data     Pointer to a buffer of \a data_len bytes.
 * \param data_len Number of bytes in the \a data buffer.
 * \return         The updated crc value.
 *****************************************************************************
crc_t crc_update(crc_t crc, const unsigned char *data, size_t data_len)
{
    unsigned int tbl_idx;

    while (data_len--) {
        tbl_idx = crc ^ (*data >> (0 * 4));
        crc = crc_table[tbl_idx & 0x0f] ^ (crc >> 4);
        tbl_idx = crc ^ (*data >> (1 * 4));
        crc = crc_table[tbl_idx & 0x0f] ^ (crc >> 4);

        data++;
    }
    return crc & 0xff;
}
</pre>
     */
    public static byte tb4_update(byte crc, final byte[] data, int data_len)
        {
        for(int data_index = 0; data_len-- > 0; )
            {
            final byte d = data[data_index++];
            int tbl_idx = (crc ^ d);
            crc = (byte) (tb4_table[tbl_idx & 0xf] ^ ((crc >> 4) & 0xf));
            tbl_idx = (crc ^ ((d >> 4) & 0xf));
            crc = (byte) (tb4_table[tbl_idx & 0xf] ^ ((crc >> 4) & 0xf));
            }
        return(crc);
        }
    /**Static table used for the contrained-size table-driven implementation. */
    private static final byte tb4_table[] =
        {
        (byte)0x00, (byte)0x9d, (byte)0x23, (byte)0xbe, (byte)0x46, (byte)0xdb, (byte)0x65, (byte)0xf8, (byte)0x8c, (byte)0x11, (byte)0xaf, (byte)0x32, (byte)0xca, (byte)0x57, (byte)0xe9, (byte)0x74
        };

    }
